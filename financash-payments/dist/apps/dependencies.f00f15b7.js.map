{"mappings":"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","sources":["node_modules/@liberquack/utils/payment/client-providers/stripe/dependencies.ts","node_modules/@liberquack/utils/ui/components/payments/stripe/stripe-elements.ts","node_modules/@liberquack/utils/ui/ui-types.ts","node_modules/haunted/lib/core.js","node_modules/haunted/lib/component.js","node_modules/haunted/lib/scheduler.js","node_modules/haunted/lib/state.js","node_modules/haunted/lib/interface.js","node_modules/haunted/lib/symbols.js","node_modules/haunted/lib/create-context.js","node_modules/haunted/lib/use-context.js","node_modules/haunted/lib/hook.js","node_modules/haunted/lib/use-effect.js","node_modules/haunted/lib/create-effect.js","node_modules/haunted/lib/use-callback.js","node_modules/haunted/lib/use-memo.js","node_modules/haunted/lib/use-controller.js","node_modules/haunted/lib/use-layout-effect.js","node_modules/haunted/lib/use-state.js","node_modules/haunted/lib/use-reducer.js","node_modules/haunted/lib/use-ref.js","node_modules/@liberquack/utils/ui/components/payments/stripe/stripe-context.ts","node_modules/haunted/lib/haunted.js","node_modules/haunted/lib/lit-haunted.js","node_modules/haunted/lib/virtual.js","node_modules/lit-html/src/directive.ts","node_modules/lit-html/src/async-directive.ts","node_modules/lit-html/src/directive-helpers.ts","node_modules/@liberquack/utils/fmt.ts","node_modules/@liberquack/utils/ui/util/define-component.ts","node_modules/@liberquack/utils/ui/util/css.ts","node_modules/@liberquack/utils/ui/components/payments/stripe/stripe-form.ts","node_modules/@liberquack/utils/ui/util/hooks/use-await.ts"],"sourcesContent":["import \"../../../ui/components/payments/stripe/stripe-elements.js\";\nimport \"../../../ui/components/payments/stripe/stripe-form.js\";\nexport {html, render} from \"lit\";","import {CreateCustomEvent} from \"../../../ui-types.js\";\nimport {useContext, useEffect, useState} from \"haunted/lib/core.js\";\nimport {StripeContext} from \"./stripe-context.js\";\nimport {Nullable} from \"../../../../_/types.js\";\nimport {html} from \"lit\";\nimport {fmt} from \"../../../../fmt.js\";\nimport {defineComponent} from \"../../../util/define-component.js\";\nimport {StripeElementsOptions, StripeElementType} from \"@stripe/stripe-js\";\n\ntype StripeElementProps = {\n    type: StripeElementType,\n    opts: StripeElementsOptions\n};\n\ntype StripeElementEvents = { \"elementready\": {} };\n\nexport const StripeElement = defineComponent<StripeElementProps, StripeElementEvents>(\"stripe-element\", {\n    func: function (props) {\n        const stripeContext = useContext(StripeContext);\n        const [stripeElm, setStripeElm] = useState(null as Nullable<HTMLElement>);\n\n        useEffect(() => {\n            if (stripeContext?.stripeElements) {\n                const stripeElm = stripeContext.stripeElements.create(props.type as any, props.opts as any);\n                const container = document.createElement(\"div\");\n                stripeElm.mount(container);\n\n                stripeElm.on(\"ready\", (e: any) => {\n                    this.dispatchEvent(CreateCustomEvent(\"elementready\", {detail: e, bubbles: true}));\n                })\n\n                setStripeElm(container);\n            }\n        }, [stripeContext?.stripeElements])\n\n        return stripeElm\n    }\n})\n\nexport const StripeSubmitErr = defineComponent(\"stripe-submit-error\", {\n    func: function() {\n        const stripeContext = useContext(StripeContext);\n        const err = stripeContext?.useSubmit?.err;\n\n        if (!err) {\n            return undefined\n        }\n\n        return html`${fmt.err(err)}`\n    }\n})\n\nexport const StripeSubmitClick = defineComponent(\"stripe-submit-click\", {\n    func: function() {\n        const stripeContext = useContext(StripeContext);\n        const submitCb = stripeContext?.useSubmit?.run;\n\n        useEffect(() => {\n            if (submitCb) {\n                this.addEventListener(\"click\", submitCb);\n                return () => this.removeEventListener(\"click\", submitCb);\n            }\n        }, [submitCb])\n    }\n})\n\nexport const StripeSubmitForm = defineComponent(\"stripe-submit-form\", {\n    func: function() {\n        const stripeContext = useContext(StripeContext);\n        const submitCb = stripeContext?.useSubmit?.run;\n\n        useEffect(() => {\n            if (submitCb) {\n                this.addEventListener(\"submit\", submitCb);\n                return () => this.removeEventListener(\"submit\", submitCb);\n            }\n        }, [submitCb])\n    }\n})","import {Assign} from \"utility-types\";\nimport {Narrow} from \"../utils.js\";\n\ntype TypedCustomEvent<N extends string, T> = Narrow<CustomEvent, { type: N, detail?: T }>;\n\nexport function CreateCustomEvent<N extends string, T>(type: N, eventInit?: CustomEventInit<T>): TypedCustomEvent<N, T>  {\n    return new window.CustomEvent(type, eventInit) as TypedCustomEvent<N, T>;\n}\n\nexport type CustomEvents = { [x:string]: any };\n\ntype EventDispatcher<E extends CustomEvents = {}> = { dispatchEvent<K extends Extract<keyof E, string>>(event: TypedCustomEvent<K, E[K]>): boolean};\n\nexport type EventListener<E extends CustomEvents = {}> = {\n    addEventListener<K extends Extract<keyof E, string>>(type: K, listener: (e: Narrow<CustomEvent, { detail: E[K] }>) => void, options?: boolean | AddEventListenerOptions): void\n}\n\nexport type CustomElement<P extends object = {}, E extends CustomEvents = {}> = Assign<HTMLElement, P & EventDispatcher<E>>;\nexport type CustomElementDefinition<P extends object= {}, E extends CustomEvents = {}> = (this: CustomElement<P, E>, props: P) => any\n\nexport type ControlProps<P extends object = {}> = Assign<{ name: string, label: any, value?: any, errMsg?: any }, P>;","import { makeComponent } from './component.js';\nimport { makeContext } from './create-context.js';\nfunction haunted({ render }) {\n    const component = makeComponent(render);\n    const createContext = makeContext(component);\n    return { component, createContext };\n}\nexport { haunted as default };\nexport { useCallback } from './use-callback.js';\nexport { useController } from './use-controller.js';\nexport { useEffect } from './use-effect.js';\nexport { useLayoutEffect } from './use-layout-effect.js';\nexport { useState } from './use-state.js';\nexport { useReducer } from './use-reducer.js';\nexport { useMemo } from './use-memo.js';\nexport { useContext } from './use-context.js';\nexport { useRef } from './use-ref.js';\nexport { hook, Hook } from './hook.js';\nexport { BaseScheduler } from './scheduler.js';\nexport { State } from './state.js';\n","import { BaseScheduler } from './scheduler.js';\nconst toCamelCase = (val = '') => val.replace(/-+([a-z])?/g, (_, char) => char ? char.toUpperCase() : '');\nfunction makeComponent(render) {\n    class Scheduler extends BaseScheduler {\n        frag;\n        constructor(renderer, frag, host) {\n            super(renderer, (host || frag));\n            this.frag = frag;\n        }\n        commit(result) {\n            render(result, this.frag);\n        }\n    }\n    function component(renderer, baseElementOrOptions, options) {\n        const BaseElement = (options || baseElementOrOptions || {}).baseElement || HTMLElement;\n        const { observedAttributes = [], useShadowDOM = true, shadowRootInit = {} } = options || baseElementOrOptions || {};\n        class Element extends BaseElement {\n            _scheduler;\n            static get observedAttributes() {\n                return renderer.observedAttributes || observedAttributes || [];\n            }\n            constructor() {\n                super();\n                if (useShadowDOM === false) {\n                    this._scheduler = new Scheduler(renderer, this);\n                }\n                else {\n                    this.attachShadow({ mode: 'open', ...shadowRootInit });\n                    this._scheduler = new Scheduler(renderer, this.shadowRoot, this);\n                }\n            }\n            connectedCallback() {\n                this._scheduler.update();\n            }\n            disconnectedCallback() {\n                this._scheduler.teardown();\n            }\n            attributeChangedCallback(name, oldValue, newValue) {\n                if (oldValue === newValue) {\n                    return;\n                }\n                let val = newValue === '' ? true : newValue;\n                Reflect.set(this, toCamelCase(name), val);\n            }\n        }\n        ;\n        function reflectiveProp(initialValue) {\n            let value = initialValue;\n            let isSetup = false;\n            return Object.freeze({\n                enumerable: true,\n                configurable: true,\n                get() {\n                    return value;\n                },\n                set(newValue) {\n                    // Avoid scheduling update when prop value hasn't changed\n                    if (isSetup && value === newValue)\n                        return;\n                    isSetup = true;\n                    value = newValue;\n                    if (this._scheduler) {\n                        this._scheduler.update();\n                    }\n                }\n            });\n        }\n        const proto = new Proxy(BaseElement.prototype, {\n            getPrototypeOf(target) {\n                return target;\n            },\n            set(target, key, value, receiver) {\n                let desc;\n                if (key in target) {\n                    desc = Object.getOwnPropertyDescriptor(target, key);\n                    if (desc && desc.set) {\n                        desc.set.call(receiver, value);\n                        return true;\n                    }\n                    Reflect.set(target, key, value, receiver);\n                    return true;\n                }\n                if (typeof key === 'symbol' || key[0] === '_') {\n                    desc = {\n                        enumerable: true,\n                        configurable: true,\n                        writable: true,\n                        value\n                    };\n                }\n                else {\n                    desc = reflectiveProp(value);\n                }\n                Object.defineProperty(receiver, key, desc);\n                if (desc.set) {\n                    desc.set.call(receiver, value);\n                }\n                return true;\n            }\n        });\n        Object.setPrototypeOf(Element.prototype, proto);\n        return Element;\n    }\n    return component;\n}\nexport { makeComponent };\n","import { State } from './state.js';\nimport { commitSymbol, phaseSymbol, updateSymbol, effectsSymbol, layoutEffectsSymbol } from './symbols.js';\nconst defer = Promise.resolve().then.bind(Promise.resolve());\nfunction runner() {\n    let tasks = [];\n    let id;\n    function runTasks() {\n        id = null;\n        let t = tasks;\n        tasks = [];\n        for (var i = 0, len = t.length; i < len; i++) {\n            t[i]();\n        }\n    }\n    return function (task) {\n        tasks.push(task);\n        if (id == null) {\n            id = defer(runTasks);\n        }\n    };\n}\nconst read = runner();\nconst write = runner();\nclass BaseScheduler {\n    renderer;\n    host;\n    state;\n    [phaseSymbol];\n    _updateQueued;\n    constructor(renderer, host) {\n        this.renderer = renderer;\n        this.host = host;\n        this.state = new State(this.update.bind(this), host);\n        this[phaseSymbol] = null;\n        this._updateQueued = false;\n    }\n    update() {\n        if (this._updateQueued)\n            return;\n        read(() => {\n            let result = this.handlePhase(updateSymbol);\n            write(() => {\n                this.handlePhase(commitSymbol, result);\n                write(() => {\n                    this.handlePhase(effectsSymbol);\n                });\n            });\n            this._updateQueued = false;\n        });\n        this._updateQueued = true;\n    }\n    handlePhase(phase, arg) {\n        this[phaseSymbol] = phase;\n        switch (phase) {\n            case commitSymbol:\n                this.commit(arg);\n                this.runEffects(layoutEffectsSymbol);\n                return;\n            case updateSymbol: return this.render();\n            case effectsSymbol: return this.runEffects(effectsSymbol);\n        }\n    }\n    render() {\n        return this.state.run(() => this.renderer.call(this.host, this.host));\n    }\n    runEffects(phase) {\n        this.state._runEffects(phase);\n    }\n    teardown() {\n        this.state.teardown();\n    }\n}\nexport { BaseScheduler };\n","import { setCurrent, clear } from './interface.js';\nimport { hookSymbol, effectsSymbol, layoutEffectsSymbol } from './symbols.js';\nclass State {\n    update;\n    host;\n    virtual;\n    [hookSymbol];\n    [effectsSymbol];\n    [layoutEffectsSymbol];\n    constructor(update, host) {\n        this.update = update;\n        this.host = host;\n        this[hookSymbol] = new Map();\n        this[effectsSymbol] = [];\n        this[layoutEffectsSymbol] = [];\n    }\n    run(cb) {\n        setCurrent(this);\n        let res = cb();\n        clear();\n        return res;\n    }\n    _runEffects(phase) {\n        let effects = this[phase];\n        setCurrent(this);\n        for (let effect of effects) {\n            effect.call(this);\n        }\n        clear();\n    }\n    runEffects() {\n        this._runEffects(effectsSymbol);\n    }\n    runLayoutEffects() {\n        this._runEffects(layoutEffectsSymbol);\n    }\n    teardown() {\n        let hooks = this[hookSymbol];\n        hooks.forEach(hook => {\n            if (typeof hook.teardown === 'function') {\n                hook.teardown();\n            }\n        });\n    }\n}\nexport { State };\n","let current;\nlet currentId = 0;\nfunction setCurrent(state) {\n    current = state;\n}\nfunction clear() {\n    current = null;\n    currentId = 0;\n}\nfunction notify() {\n    return currentId++;\n}\nexport { clear, current, setCurrent, notify };\n","const phaseSymbol = Symbol('haunted.phase');\nconst hookSymbol = Symbol('haunted.hook');\nconst updateSymbol = Symbol('haunted.update');\nconst commitSymbol = Symbol('haunted.commit');\nconst effectsSymbol = Symbol('haunted.effects');\nconst layoutEffectsSymbol = Symbol('haunted.layoutEffects');\nconst contextEvent = 'haunted.context';\nexport { phaseSymbol, hookSymbol, updateSymbol, commitSymbol, effectsSymbol, layoutEffectsSymbol, contextEvent, };\n","import { contextEvent } from './symbols.js';\nimport { useContext } from './use-context.js';\nfunction makeContext(component) {\n    return (defaultValue) => {\n        const Context = {\n            Provider: class extends HTMLElement {\n                listeners;\n                _value;\n                constructor() {\n                    super();\n                    this.listeners = new Set();\n                    this.addEventListener(contextEvent, this);\n                }\n                disconnectedCallback() {\n                    this.removeEventListener(contextEvent, this);\n                }\n                handleEvent(event) {\n                    const { detail } = event;\n                    if (detail.Context === Context) {\n                        detail.value = this.value;\n                        detail.unsubscribe = this.unsubscribe.bind(this, detail.callback);\n                        this.listeners.add(detail.callback);\n                        event.stopPropagation();\n                    }\n                }\n                unsubscribe(callback) {\n                    this.listeners.delete(callback);\n                }\n                set value(value) {\n                    this._value = value;\n                    for (let callback of this.listeners) {\n                        callback(value);\n                    }\n                }\n                get value() {\n                    return this._value;\n                }\n            },\n            Consumer: component(function ({ render }) {\n                const context = useContext(Context);\n                return render(context);\n            }),\n            defaultValue,\n        };\n        return Context;\n    };\n}\nexport { makeContext };\n","import { hook, Hook } from './hook.js';\nimport { contextEvent } from './symbols.js';\nimport { setEffects } from './use-effect.js';\n/**\n * @function\n * @template T\n * @param    {Context<T>} context\n * @return   {T}\n */\nconst useContext = hook(class extends Hook {\n    Context;\n    value;\n    _ranEffect;\n    _unsubscribe;\n    constructor(id, state, _) {\n        super(id, state);\n        this._updater = this._updater.bind(this);\n        this._ranEffect = false;\n        this._unsubscribe = null;\n        setEffects(state, this);\n    }\n    update(Context) {\n        if (this.state.virtual) {\n            throw new Error('can\\'t be used with virtual components');\n        }\n        if (this.Context !== Context) {\n            this._subscribe(Context);\n            this.Context = Context;\n        }\n        return this.value;\n    }\n    call() {\n        if (!this._ranEffect) {\n            this._ranEffect = true;\n            if (this._unsubscribe)\n                this._unsubscribe();\n            this._subscribe(this.Context);\n            this.state.update();\n        }\n    }\n    _updater(value) {\n        this.value = value;\n        this.state.update();\n    }\n    _subscribe(Context) {\n        const detail = { Context, callback: this._updater };\n        this.state.host.dispatchEvent(new CustomEvent(contextEvent, {\n            detail,\n            bubbles: true,\n            cancelable: true,\n            composed: true, // to pass ShadowDOM boundaries\n        }));\n        const { unsubscribe = null, value } = detail;\n        this.value = unsubscribe ? value : Context.defaultValue;\n        this._unsubscribe = unsubscribe;\n    }\n    teardown() {\n        if (this._unsubscribe) {\n            this._unsubscribe();\n        }\n    }\n});\nexport { useContext };\n","import { current, notify } from './interface.js';\nimport { hookSymbol } from './symbols.js';\nclass Hook {\n    id;\n    state;\n    constructor(id, state) {\n        this.id = id;\n        this.state = state;\n    }\n}\nfunction use(Hook, ...args) {\n    let id = notify();\n    let hooks = current[hookSymbol];\n    let hook = hooks.get(id);\n    if (!hook) {\n        hook = new Hook(id, current, ...args);\n        hooks.set(id, hook);\n    }\n    return hook.update(...args);\n}\nfunction hook(Hook) {\n    return use.bind(null, Hook);\n}\nexport { hook, Hook };\n","import { effectsSymbol } from './symbols.js';\nimport { createEffect } from './create-effect.js';\nfunction setEffects(state, cb) {\n    state[effectsSymbol].push(cb);\n}\n/**\n * @function\n * @param {() => void} effect - callback function that runs each time dependencies change\n * @param {unknown[]} [dependencies] - list of dependencies to the effect\n * @return {void}\n */\nconst useEffect = createEffect(setEffects);\nexport { setEffects, useEffect };\n","import { Hook, hook } from './hook.js';\nfunction createEffect(setEffects) {\n    return hook(class extends Hook {\n        callback;\n        lastValues;\n        values;\n        _teardown;\n        constructor(id, state, ignored1, ignored2) {\n            super(id, state);\n            setEffects(state, this);\n        }\n        update(callback, values) {\n            this.callback = callback;\n            this.values = values;\n        }\n        call() {\n            if (!this.values || this.hasChanged()) {\n                this.run();\n            }\n            this.lastValues = this.values;\n        }\n        run() {\n            this.teardown();\n            this._teardown = this.callback.call(this.state);\n        }\n        teardown() {\n            if (typeof this._teardown === 'function') {\n                this._teardown();\n            }\n        }\n        hasChanged() {\n            return !this.lastValues || this.values.some((value, i) => this.lastValues[i] !== value);\n        }\n    });\n}\nexport { createEffect };\n","import { useMemo } from './use-memo.js';\n/**\n * @function\n * @template {Function} T\n * @param    {T} fn - callback to memoize\n * @param    {unknown[]} inputs - dependencies to callback memoization\n * @return   {T}\n */\nconst useCallback = (fn, inputs) => useMemo(() => fn, inputs);\nexport { useCallback };\n","import { hook, Hook } from './hook.js';\n/**\n * @function\n * @template T\n * @param  {() => T} fn function to memoize\n * @param  {unknown[]} values dependencies to the memoized computation\n * @return {T} The next computed value\n */\nconst useMemo = hook(class extends Hook {\n    value;\n    values;\n    constructor(id, state, fn, values) {\n        super(id, state);\n        this.value = fn();\n        this.values = values;\n    }\n    update(fn, values) {\n        if (this.hasChanged(values)) {\n            this.values = values;\n            this.value = fn();\n        }\n        return this.value;\n    }\n    hasChanged(values = []) {\n        return values.some((value, i) => this.values[i] !== value);\n    }\n});\nexport { useMemo };\n","/**\n * @license\n * Portions Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { useLayoutEffect } from './use-layout-effect.js';\nimport { useState } from './use-state.js';\nconst microtask = Promise.resolve();\n/**\n * An implementation of ReactiveControllerHost that is driven by Haunted hooks\n * and `useController()`.\n */\nclass HauntedControllerHost {\n    count;\n    kick;\n    _controllers = [];\n    _updatePending = true;\n    _updateCompletePromise;\n    _resolveUpdate;\n    constructor(count, kick) {\n        this.count = count;\n        this.kick = kick;\n        this._updateCompletePromise = new Promise(res => {\n            this._resolveUpdate = res;\n        });\n    }\n    addController(controller) {\n        this._controllers.push(controller);\n    }\n    removeController(controller) {\n        // Note, if the indexOf is -1, the >>> will flip the sign which makes the\n        // splice do nothing.\n        this._controllers && this._controllers.splice(this._controllers.indexOf(controller) >>> 0, 1);\n    }\n    requestUpdate() {\n        if (!this._updatePending) {\n            this._updatePending = true;\n            microtask.then(() => this.kick(this.count + 1));\n        }\n    }\n    get updateComplete() {\n        return this._updateCompletePromise;\n    }\n    connected() {\n        this._controllers.forEach(c => c.hostConnected && c.hostConnected());\n    }\n    disconnected() {\n        this._controllers.forEach(c => c.hostDisconnected && c.hostDisconnected());\n    }\n    update() {\n        this._controllers.forEach(c => c.hostUpdate && c.hostUpdate());\n    }\n    updated() {\n        this._updatePending = false;\n        const resolve = this._resolveUpdate;\n        // Create a new updateComplete Promise for the next update,\n        // before resolving the current one.\n        this._updateCompletePromise = new Promise(res => {\n            this._resolveUpdate = res;\n        });\n        this._controllers.forEach(c => c.hostUpdated && c.hostUpdated());\n        resolve(this._updatePending);\n    }\n}\n/**\n * Creates and stores a stateful ReactiveController instance and provides it\n * with a ReactiveControllerHost that drives the controller lifecycle.\n *\n * Use this hook to convert a ReactiveController into a Haunted hook.\n *\n * @param {<C extends ReactiveController>(host: ReactiveControllerHost) => C} createController A function that creates a controller instance.\n * This function is given a HauntedControllerHost to pass to the controller. The\n * create function is only called once per component.\n * @return {ReactiveController} the controller instance\n */\nexport function useController(createController) {\n    const [count, kick] = useState(0);\n    const [host] = useState(() => {\n        const host = new HauntedControllerHost(count, kick);\n        const controller = createController(host);\n        host.primaryController = controller;\n        host.connected();\n        return host;\n    });\n    // We use useLayoutEffect because we need updated() called synchronously\n    // after rendering.\n    useLayoutEffect(() => host.updated());\n    // Returning a cleanup function simulates hostDisconnected timing. An empty\n    // deps array tells Haunted to only call this once: on mount with the cleanup\n    // called on unmount.\n    useLayoutEffect(() => () => host.disconnected(), []);\n    host.update();\n    return host.primaryController;\n}\n","import { layoutEffectsSymbol } from './symbols.js';\nimport { createEffect } from './create-effect.js';\nfunction setLayoutEffects(state, cb) {\n    state[layoutEffectsSymbol].push(cb);\n}\n/**\n * @function\n * @param  {Effect} callback effecting callback\n * @param  {unknown[]} [values] dependencies to the effect\n * @return {void}\n */\nconst useLayoutEffect = createEffect(setLayoutEffects);\nexport { useLayoutEffect };\n","import { hook, Hook } from './hook.js';\n/**\n * @function\n * @template {*} T\n * @param {T} [initialState] - Optional initial state\n * @return {readonly [state: T, updaterFn: StateUpdater<T>]} stateTuple - Tuple of current state and state updater function\n */\nconst useState = hook(class extends Hook {\n    args;\n    constructor(id, state, initialValue) {\n        super(id, state);\n        this.updater = this.updater.bind(this);\n        if (typeof initialValue === 'function') {\n            initialValue = initialValue();\n        }\n        this.makeArgs(initialValue);\n    }\n    update() {\n        return this.args;\n    }\n    updater(value) {\n        if (typeof value === 'function') {\n            const updaterFn = value;\n            const [previousValue] = this.args;\n            value = updaterFn(previousValue);\n        }\n        this.makeArgs(value);\n        this.state.update();\n    }\n    makeArgs(value) {\n        this.args = Object.freeze([value, this.updater]);\n    }\n});\n;\nexport { useState };\n","import { hook, Hook } from './hook.js';\n/**\n * Given a reducer function, initial state, and optional state initializer function, returns a tuple of state and dispatch function.\n * @function\n * @template S State\n * @template I Initial State\n * @template A Action\n * @param {Reducer<S, A>} reducer - reducer function to compute the next state given the previous state and the action\n * @param {I} initialState - the initial state of the reducer\n * @param {(init: I) => S} [init=undefined] - Optional initializer function, called on initialState if provided\n * @return {readonly [S, (action: A) => void]}\n */\nconst useReducer = hook(class extends Hook {\n    reducer;\n    currentState;\n    constructor(id, state, _, initialState, init) {\n        super(id, state);\n        this.dispatch = this.dispatch.bind(this);\n        this.currentState = init !== undefined ? init(initialState) : initialState;\n    }\n    update(reducer) {\n        this.reducer = reducer;\n        return [this.currentState, this.dispatch];\n    }\n    dispatch(action) {\n        this.currentState = this.reducer(this.currentState, action);\n        this.state.update();\n    }\n});\nexport { useReducer };\n","import { useMemo } from './use-memo.js';\n/**\n * @function\n * @template T\n * @param   {T} initialValue\n * @return  {{ current: T }} Ref\n */\nconst useRef = (initialValue) => useMemo(() => ({\n    current: initialValue\n}), []);\nexport { useRef };\n","import {createContext} from \"haunted\";\nimport {Nullable} from \"../../../../_/types.js\";\nimport {StripeContextType} from \"./types.js\";\n\nexport const StripeContext = createContext(null as Nullable<StripeContextType>);\ncustomElements.define(\"stripe-provider\", StripeContext.Provider);","export { html, render, component, createContext, virtual } from './lit-haunted.js';\nexport * from './core.js';\nexport { default } from './core.js';\n","import { html, render } from 'lit';\nimport haunted from './core.js';\nimport { makeVirtual } from './virtual.js';\nconst { component, createContext } = haunted({ render });\nconst virtual = makeVirtual();\nexport { component, createContext, virtual, html, render };\n","import { directive } from 'lit/directive.js';\nimport { noChange } from 'lit';\nimport { AsyncDirective } from 'lit/async-directive.js';\nimport { BaseScheduler } from './scheduler.js';\nconst includes = Array.prototype.includes;\nconst partToScheduler = new WeakMap();\nconst schedulerToPart = new WeakMap();\nclass Scheduler extends BaseScheduler {\n    args;\n    setValue;\n    constructor(renderer, part, setValue) {\n        super(renderer, part);\n        this.state.virtual = true;\n        this.setValue = setValue;\n    }\n    render() {\n        return this.state.run(() => this.renderer.apply(this.host, this.args));\n    }\n    commit(result) {\n        this.setValue(result);\n    }\n    teardown() {\n        super.teardown();\n        let part = schedulerToPart.get(this);\n        partToScheduler.delete(part);\n    }\n}\nfunction makeVirtual() {\n    function virtual(renderer) {\n        class VirtualDirective extends AsyncDirective {\n            cont;\n            constructor(partInfo) {\n                super(partInfo);\n                this.cont = undefined;\n            }\n            update(part, args) {\n                this.cont = partToScheduler.get(part);\n                if (!this.cont || this.cont.renderer !== renderer) {\n                    this.cont = new Scheduler(renderer, part, (r) => { this.setValue(r); });\n                    partToScheduler.set(part, this.cont);\n                    schedulerToPart.set(this.cont, part);\n                    teardownOnRemove(this.cont, part);\n                }\n                this.cont.args = args;\n                this.cont.update();\n                return this.render(args);\n            }\n            render(args) {\n                return noChange;\n            }\n        }\n        return directive(VirtualDirective);\n    }\n    return virtual;\n}\nfunction teardownOnRemove(cont, part, node = part.startNode) {\n    let frag = node.parentNode;\n    let mo = new MutationObserver(mutations => {\n        for (let mutation of mutations) {\n            if (includes.call(mutation.removedNodes, node)) {\n                mo.disconnect();\n                if (node.parentNode instanceof ShadowRoot) {\n                    teardownOnRemove(cont, part);\n                }\n                else {\n                    cont.teardown();\n                }\n                break;\n            }\n            else if (includes.call(mutation.addedNodes, node.nextSibling)) {\n                mo.disconnect();\n                teardownOnRemove(cont, part, node.nextSibling || undefined);\n                break;\n            }\n        }\n    });\n    mo.observe(frag, { childList: true });\n}\nexport { makeVirtual };\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {Disconnectable, Part} from './lit-html.js';\n\nexport {\n  AttributePart,\n  BooleanAttributePart,\n  ChildPart,\n  ElementPart,\n  EventPart,\n  Part,\n  PropertyPart,\n} from './lit-html.js';\n\nexport interface DirectiveClass {\n  new (part: PartInfo): Directive;\n}\n\n/**\n * This utility type extracts the signature of a directive class's render()\n * method so we can use it for the type of the generated directive function.\n */\nexport type DirectiveParameters<C extends Directive> = Parameters<C['render']>;\n\n/**\n * A generated directive function doesn't evaluate the directive, but just\n * returns a DirectiveResult object that captures the arguments.\n */\nexport interface DirectiveResult<C extends DirectiveClass = DirectiveClass> {\n  /**\n   * This property needs to remain unminified.\n   * @internal */\n  ['_$litDirective$']: C;\n  /** @internal */\n  values: DirectiveParameters<InstanceType<C>>;\n}\n\nexport const PartType = {\n  ATTRIBUTE: 1,\n  CHILD: 2,\n  PROPERTY: 3,\n  BOOLEAN_ATTRIBUTE: 4,\n  EVENT: 5,\n  ELEMENT: 6,\n} as const;\n\nexport type PartType = typeof PartType[keyof typeof PartType];\n\nexport interface ChildPartInfo {\n  readonly type: typeof PartType.CHILD;\n}\n\nexport interface AttributePartInfo {\n  readonly type:\n    | typeof PartType.ATTRIBUTE\n    | typeof PartType.PROPERTY\n    | typeof PartType.BOOLEAN_ATTRIBUTE\n    | typeof PartType.EVENT;\n  readonly strings?: ReadonlyArray<string>;\n  readonly name: string;\n  readonly tagName: string;\n}\n\nexport interface ElementPartInfo {\n  readonly type: typeof PartType.ELEMENT;\n}\n\n/**\n * Information about the part a directive is bound to.\n *\n * This is useful for checking that a directive is attached to a valid part,\n * such as with directive that can only be used on attribute bindings.\n */\nexport type PartInfo = ChildPartInfo | AttributePartInfo | ElementPartInfo;\n\n/**\n * Creates a user-facing directive function from a Directive class. This\n * function has the same parameters as the directive's render() method.\n */\nexport const directive =\n  <C extends DirectiveClass>(c: C) =>\n  (...values: DirectiveParameters<InstanceType<C>>): DirectiveResult<C> => ({\n    // This property needs to remain unminified.\n    ['_$litDirective$']: c,\n    values,\n  });\n\n/**\n * Base class for creating custom directives. Users should extend this class,\n * implement `render` and/or `update`, and then pass their subclass to\n * `directive`.\n */\nexport abstract class Directive implements Disconnectable {\n  //@internal\n  __part!: Part;\n  //@internal\n  __attributeIndex: number | undefined;\n  //@internal\n  __directive?: Directive;\n\n  //@internal\n  _$parent!: Disconnectable;\n\n  // These will only exist on the AsyncDirective subclass\n  //@internal\n  _$disconnectableChildren?: Set<Disconnectable>;\n  // This property needs to remain unminified.\n  //@internal\n  ['_$notifyDirectiveConnectionChanged']?(isConnected: boolean): void;\n\n  constructor(_partInfo: PartInfo) {}\n\n  // See comment in Disconnectable interface for why this is a getter\n  get _$isConnected() {\n    return this._$parent._$isConnected;\n  }\n\n  /** @internal */\n  _$initialize(\n    part: Part,\n    parent: Disconnectable,\n    attributeIndex: number | undefined\n  ) {\n    this.__part = part;\n    this._$parent = parent;\n    this.__attributeIndex = attributeIndex;\n  }\n  /** @internal */\n  _$resolve(part: Part, props: Array<unknown>): unknown {\n    return this.update(part, props);\n  }\n\n  abstract render(...props: Array<unknown>): unknown;\n\n  update(_part: Part, props: Array<unknown>): unknown {\n    return this.render(...props);\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * Overview:\n *\n * This module is designed to add support for an async `setValue` API and\n * `disconnected` callback to directives with the least impact on the core\n * runtime or payload when that feature is not used.\n *\n * The strategy is to introduce a `AsyncDirective` subclass of\n * `Directive` that climbs the \"parent\" tree in its constructor to note which\n * branches of lit-html's \"logical tree\" of data structures contain such\n * directives and thus need to be crawled when a subtree is being cleared (or\n * manually disconnected) in order to run the `disconnected` callback.\n *\n * The \"nodes\" of the logical tree include Parts, TemplateInstances (for when a\n * TemplateResult is committed to a value of a ChildPart), and Directives; these\n * all implement a common interface called `DisconnectableChild`. Each has a\n * `_$parent` reference which is set during construction in the core code, and a\n * `_$disconnectableChildren` field which is initially undefined.\n *\n * The sparse tree created by means of the `AsyncDirective` constructor\n * crawling up the `_$parent` tree and placing a `_$disconnectableChildren` Set\n * on each parent that includes each child that contains a\n * `AsyncDirective` directly or transitively via its children. In order to\n * notify connection state changes and disconnect (or reconnect) a tree, the\n * `_$notifyConnectionChanged` API is patched onto ChildParts as a directive\n * climbs the parent tree, which is called by the core when clearing a part if\n * it exists. When called, that method iterates over the sparse tree of\n * Set<DisconnectableChildren> built up by AsyncDirectives, and calls\n * `_$notifyDirectiveConnectionChanged` on any directives that are encountered\n * in that tree, running the required callbacks.\n *\n * A given \"logical tree\" of lit-html data-structures might look like this:\n *\n *  ChildPart(N1) _$dC=[D2,T3]\n *   ._directive\n *     AsyncDirective(D2)\n *   ._value // user value was TemplateResult\n *     TemplateInstance(T3) _$dC=[A4,A6,N10,N12]\n *      ._parts[]\n *        AttributePart(A4) _$dC=[D5]\n *         ._directives[]\n *           AsyncDirective(D5)\n *        AttributePart(A6) _$dC=[D7,D8]\n *         ._directives[]\n *           AsyncDirective(D7)\n *           Directive(D8) _$dC=[D9]\n *            ._directive\n *              AsyncDirective(D9)\n *        ChildPart(N10) _$dC=[D11]\n *         ._directive\n *           AsyncDirective(D11)\n *         ._value\n *           string\n *        ChildPart(N12) _$dC=[D13,N14,N16]\n *         ._directive\n *           AsyncDirective(D13)\n *         ._value // user value was iterable\n *           Array<ChildPart>\n *             ChildPart(N14) _$dC=[D15]\n *              ._value\n *                string\n *             ChildPart(N16) _$dC=[D17,T18]\n *              ._directive\n *                AsyncDirective(D17)\n *              ._value // user value was TemplateResult\n *                TemplateInstance(T18) _$dC=[A19,A21,N25]\n *                 ._parts[]\n *                   AttributePart(A19) _$dC=[D20]\n *                    ._directives[]\n *                      AsyncDirective(D20)\n *                   AttributePart(A21) _$dC=[22,23]\n *                    ._directives[]\n *                      AsyncDirective(D22)\n *                      Directive(D23) _$dC=[D24]\n *                       ._directive\n *                         AsyncDirective(D24)\n *                   ChildPart(N25) _$dC=[D26]\n *                    ._directive\n *                      AsyncDirective(D26)\n *                    ._value\n *                      string\n *\n * Example 1: The directive in ChildPart(N12) updates and returns `nothing`. The\n * ChildPart will _clear() itself, and so we need to disconnect the \"value\" of\n * the ChildPart (but not its directive). In this case, when `_clear()` calls\n * `_$notifyConnectionChanged()`, we don't iterate all of the\n * _$disconnectableChildren, rather we do a value-specific disconnection: i.e.\n * since the _value was an Array<ChildPart> (because an iterable had been\n * committed), we iterate the array of ChildParts (N14, N16) and run\n * `setConnected` on them (which does recurse down the full tree of\n * `_$disconnectableChildren` below it, and also removes N14 and N16 from N12's\n * `_$disconnectableChildren`). Once the values have been disconnected, we then\n * check whether the ChildPart(N12)'s list of `_$disconnectableChildren` is empty\n * (and would remove it from its parent TemplateInstance(T3) if so), but since\n * it would still contain its directive D13, it stays in the disconnectable\n * tree.\n *\n * Example 2: In the course of Example 1, `setConnected` will reach\n * ChildPart(N16); in this case the entire part is being disconnected, so we\n * simply iterate all of N16's `_$disconnectableChildren` (D17,T18) and\n * recursively run `setConnected` on them. Note that we only remove children\n * from `_$disconnectableChildren` for the top-level values being disconnected\n * on a clear; doing this bookkeeping lower in the tree is wasteful since it's\n * all being thrown away.\n *\n * Example 3: If the LitElement containing the entire tree above becomes\n * disconnected, it will run `childPart.setConnected()` (which calls\n * `childPart._$notifyConnectionChanged()` if it exists); in this case, we\n * recursively run `setConnected()` over the entire tree, without removing any\n * children from `_$disconnectableChildren`, since this tree is required to\n * re-connect the tree, which does the same operation, simply passing\n * `isConnected: true` down the tree, signaling which callback to run.\n */\n\nimport {AttributePart, ChildPart, Disconnectable, Part} from './lit-html.js';\nimport {isSingleExpression} from './directive-helpers.js';\nimport {Directive, PartInfo, PartType} from './directive.js';\nexport {directive} from './directive.js';\n\nconst DEV_MODE = true;\n\n/**\n * Recursively walks down the tree of Parts/TemplateInstances/Directives to set\n * the connected state of directives and run `disconnected`/ `reconnected`\n * callbacks.\n *\n * @return True if there were children to disconnect; false otherwise\n */\nconst notifyChildrenConnectedChanged = (\n  parent: Disconnectable,\n  isConnected: boolean\n): boolean => {\n  const children = parent._$disconnectableChildren;\n  if (children === undefined) {\n    return false;\n  }\n  for (const obj of children) {\n    // The existence of `_$notifyDirectiveConnectionChanged` is used as a \"brand\" to\n    // disambiguate AsyncDirectives from other DisconnectableChildren\n    // (as opposed to using an instanceof check to know when to call it); the\n    // redundancy of \"Directive\" in the API name is to avoid conflicting with\n    // `_$notifyConnectionChanged`, which exists `ChildParts` which are also in\n    // this list\n    // Disconnect Directive (and any nested directives contained within)\n    // This property needs to remain unminified.\n    (obj as AsyncDirective)['_$notifyDirectiveConnectionChanged']?.(\n      isConnected,\n      false\n    );\n    // Disconnect Part/TemplateInstance\n    notifyChildrenConnectedChanged(obj, isConnected);\n  }\n  return true;\n};\n\n/**\n * Removes the given child from its parent list of disconnectable children, and\n * if the parent list becomes empty as a result, removes the parent from its\n * parent, and so forth up the tree when that causes subsequent parent lists to\n * become empty.\n */\nconst removeDisconnectableFromParent = (obj: Disconnectable) => {\n  let parent, children;\n  do {\n    if ((parent = obj._$parent) === undefined) {\n      break;\n    }\n    children = parent._$disconnectableChildren!;\n    children.delete(obj);\n    obj = parent;\n  } while (children?.size === 0);\n};\n\nconst addDisconnectableToParent = (obj: Disconnectable) => {\n  // Climb the parent tree, creating a sparse tree of children needing\n  // disconnection\n  for (let parent; (parent = obj._$parent); obj = parent) {\n    let children = parent._$disconnectableChildren;\n    if (children === undefined) {\n      parent._$disconnectableChildren = children = new Set();\n    } else if (children.has(obj)) {\n      // Once we've reached a parent that already contains this child, we\n      // can short-circuit\n      break;\n    }\n    children.add(obj);\n    installDisconnectAPI(parent);\n  }\n};\n\n/**\n * Changes the parent reference of the ChildPart, and updates the sparse tree of\n * Disconnectable children accordingly.\n *\n * Note, this method will be patched onto ChildPart instances and called from\n * the core code when parts are moved between different parents.\n */\nfunction reparentDisconnectables(this: ChildPart, newParent: Disconnectable) {\n  if (this._$disconnectableChildren !== undefined) {\n    removeDisconnectableFromParent(this);\n    this._$parent = newParent;\n    addDisconnectableToParent(this);\n  } else {\n    this._$parent = newParent;\n  }\n}\n\n/**\n * Sets the connected state on any directives contained within the committed\n * value of this part (i.e. within a TemplateInstance or iterable of\n * ChildParts) and runs their `disconnected`/`reconnected`s, as well as within\n * any directives stored on the ChildPart (when `valueOnly` is false).\n *\n * `isClearingValue` should be passed as `true` on a top-level part that is\n * clearing itself, and not as a result of recursively disconnecting directives\n * as part of a `clear` operation higher up the tree. This both ensures that any\n * directive on this ChildPart that produced a value that caused the clear\n * operation is not disconnected, and also serves as a performance optimization\n * to avoid needless bookkeeping when a subtree is going away; when clearing a\n * subtree, only the top-most part need to remove itself from the parent.\n *\n * `fromPartIndex` is passed only in the case of a partial `_clear` running as a\n * result of truncating an iterable.\n *\n * Note, this method will be patched onto ChildPart instances and called from the\n * core code when parts are cleared or the connection state is changed by the\n * user.\n */\nfunction notifyChildPartConnectedChanged(\n  this: ChildPart,\n  isConnected: boolean,\n  isClearingValue = false,\n  fromPartIndex = 0\n) {\n  const value = this._$committedValue;\n  const children = this._$disconnectableChildren;\n  if (children === undefined || children.size === 0) {\n    return;\n  }\n  if (isClearingValue) {\n    if (Array.isArray(value)) {\n      // Iterable case: Any ChildParts created by the iterable should be\n      // disconnected and removed from this ChildPart's disconnectable\n      // children (starting at `fromPartIndex` in the case of truncation)\n      for (let i = fromPartIndex; i < value.length; i++) {\n        notifyChildrenConnectedChanged(value[i], false);\n        removeDisconnectableFromParent(value[i]);\n      }\n    } else if (value != null) {\n      // TemplateInstance case: If the value has disconnectable children (will\n      // only be in the case that it is a TemplateInstance), we disconnect it\n      // and remove it from this ChildPart's disconnectable children\n      notifyChildrenConnectedChanged(value as Disconnectable, false);\n      removeDisconnectableFromParent(value as Disconnectable);\n    }\n  } else {\n    notifyChildrenConnectedChanged(this, isConnected);\n  }\n}\n\n/**\n * Patches disconnection API onto ChildParts.\n */\nconst installDisconnectAPI = (obj: Disconnectable) => {\n  if ((obj as ChildPart).type == PartType.CHILD) {\n    (obj as ChildPart)._$notifyConnectionChanged ??=\n      notifyChildPartConnectedChanged;\n    (obj as ChildPart)._$reparentDisconnectables ??= reparentDisconnectables;\n  }\n};\n\n/**\n * An abstract `Directive` base class whose `disconnected` method will be\n * called when the part containing the directive is cleared as a result of\n * re-rendering, or when the user calls `part.setConnected(false)` on\n * a part that was previously rendered containing the directive (as happens\n * when e.g. a LitElement disconnects from the DOM).\n *\n * If `part.setConnected(true)` is subsequently called on a\n * containing part, the directive's `reconnected` method will be called prior\n * to its next `update`/`render` callbacks. When implementing `disconnected`,\n * `reconnected` should also be implemented to be compatible with reconnection.\n *\n * Note that updates may occur while the directive is disconnected. As such,\n * directives should generally check the `this.isConnected` flag during\n * render/update to determine whether it is safe to subscribe to resources\n * that may prevent garbage collection.\n */\nexport abstract class AsyncDirective extends Directive {\n  // As opposed to other Disconnectables, AsyncDirectives always get notified\n  // when the RootPart connection changes, so the public `isConnected`\n  // is a locally stored variable initialized via its part's getter and synced\n  // via `_$notifyDirectiveConnectionChanged`. This is cheaper than using\n  // the _$isConnected getter, which has to look back up the tree each time.\n  /**\n   * The connection state for this Directive.\n   */\n  isConnected!: boolean;\n\n  // @internal\n  override _$disconnectableChildren?: Set<Disconnectable> = undefined;\n  /**\n   * Initialize the part with internal fields\n   * @param part\n   * @param parent\n   * @param attributeIndex\n   */\n  override _$initialize(\n    part: Part,\n    parent: Disconnectable,\n    attributeIndex: number | undefined\n  ) {\n    super._$initialize(part, parent, attributeIndex);\n    addDisconnectableToParent(this);\n    this.isConnected = part._$isConnected;\n  }\n  // This property needs to remain unminified.\n  /**\n   * Called from the core code when a directive is going away from a part (in\n   * which case `shouldRemoveFromParent` should be true), and from the\n   * `setChildrenConnected` helper function when recursively changing the\n   * connection state of a tree (in which case `shouldRemoveFromParent` should\n   * be false).\n   *\n   * @param isConnected\n   * @param isClearingDirective - True when the directive itself is being\n   *     removed; false when the tree is being disconnected\n   * @internal\n   */\n  override ['_$notifyDirectiveConnectionChanged'](\n    isConnected: boolean,\n    isClearingDirective = true\n  ) {\n    if (isConnected !== this.isConnected) {\n      this.isConnected = isConnected;\n      if (isConnected) {\n        this.reconnected?.();\n      } else {\n        this.disconnected?.();\n      }\n    }\n    if (isClearingDirective) {\n      notifyChildrenConnectedChanged(this, isConnected);\n      removeDisconnectableFromParent(this);\n    }\n  }\n\n  /**\n   * Sets the value of the directive's Part outside the normal `update`/`render`\n   * lifecycle of a directive.\n   *\n   * This method should not be called synchronously from a directive's `update`\n   * or `render`.\n   *\n   * @param directive The directive to update\n   * @param value The value to set\n   */\n  setValue(value: unknown) {\n    if (isSingleExpression(this.__part as unknown as PartInfo)) {\n      this.__part._$setValue(value, this);\n    } else {\n      // this.__attributeIndex will be defined in this case, but\n      // assert it in dev mode\n      if (DEV_MODE && this.__attributeIndex === undefined) {\n        throw new Error(`Expected this.__attributeIndex to be a number`);\n      }\n      const newValues = [...(this.__part._$committedValue as Array<unknown>)];\n      newValues[this.__attributeIndex!] = value;\n      (this.__part as AttributePart)._$setValue(newValues, this, 0);\n    }\n  }\n\n  /**\n   * User callbacks for implementing logic to release any resources/subscriptions\n   * that may have been retained by this directive. Since directives may also be\n   * re-connected, `reconnected` should also be implemented to restore the\n   * working state of the directive prior to the next render.\n   */\n  protected disconnected() {}\n  protected reconnected() {}\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {_$LH, Part, DirectiveParent, TemplateResult} from './lit-html.js';\nimport {\n  DirectiveResult,\n  DirectiveClass,\n  PartInfo,\n  AttributePartInfo,\n} from './directive.js';\ntype Primitive = null | undefined | boolean | number | string | symbol | bigint;\n\nconst {_ChildPart: ChildPart} = _$LH;\n\ntype ChildPart = InstanceType<typeof ChildPart>;\n\nconst ENABLE_SHADYDOM_NOPATCH = true;\n\nconst wrap =\n  ENABLE_SHADYDOM_NOPATCH &&\n  window.ShadyDOM?.inUse &&\n  window.ShadyDOM?.noPatch === true\n    ? window.ShadyDOM!.wrap\n    : (node: Node) => node;\n\n/**\n * Tests if a value is a primitive value.\n *\n * See https://tc39.github.io/ecma262/#sec-typeof-operator\n */\nexport const isPrimitive = (value: unknown): value is Primitive =>\n  value === null || (typeof value != 'object' && typeof value != 'function');\n\nexport const TemplateResultType = {\n  HTML: 1,\n  SVG: 2,\n} as const;\n\nexport type TemplateResultType =\n  typeof TemplateResultType[keyof typeof TemplateResultType];\n\n/**\n * Tests if a value is a TemplateResult.\n */\nexport const isTemplateResult = (\n  value: unknown,\n  type?: TemplateResultType\n): value is TemplateResult =>\n  type === undefined\n    ? // This property needs to remain unminified.\n      (value as TemplateResult)?.['_$litType$'] !== undefined\n    : (value as TemplateResult)?.['_$litType$'] === type;\n\n/**\n * Tests if a value is a DirectiveResult.\n */\nexport const isDirectiveResult = (value: unknown): value is DirectiveResult =>\n  // This property needs to remain unminified.\n  (value as DirectiveResult)?.['_$litDirective$'] !== undefined;\n\n/**\n * Retrieves the Directive class for a DirectiveResult\n */\nexport const getDirectiveClass = (value: unknown): DirectiveClass | undefined =>\n  // This property needs to remain unminified.\n  (value as DirectiveResult)?.['_$litDirective$'];\n\n/**\n * Tests whether a part has only a single-expression with no strings to\n * interpolate between.\n *\n * Only AttributePart and PropertyPart can have multiple expressions.\n * Multi-expression parts have a `strings` property and single-expression\n * parts do not.\n */\nexport const isSingleExpression = (part: PartInfo) =>\n  (part as AttributePartInfo).strings === undefined;\n\nconst createMarker = () => document.createComment('');\n\n/**\n * Inserts a ChildPart into the given container ChildPart's DOM, either at the\n * end of the container ChildPart, or before the optional `refPart`.\n *\n * This does not add the part to the containerPart's committed value. That must\n * be done by callers.\n *\n * @param containerPart Part within which to add the new ChildPart\n * @param refPart Part before which to add the new ChildPart; when omitted the\n *     part added to the end of the `containerPart`\n * @param part Part to insert, or undefined to create a new part\n */\nexport const insertPart = (\n  containerPart: ChildPart,\n  refPart?: ChildPart,\n  part?: ChildPart\n): ChildPart => {\n  const container = wrap(containerPart._$startNode).parentNode!;\n\n  const refNode =\n    refPart === undefined ? containerPart._$endNode : refPart._$startNode;\n\n  if (part === undefined) {\n    const startNode = wrap(container).insertBefore(createMarker(), refNode);\n    const endNode = wrap(container).insertBefore(createMarker(), refNode);\n    part = new ChildPart(\n      startNode,\n      endNode,\n      containerPart,\n      containerPart.options\n    );\n  } else {\n    const endNode = wrap(part._$endNode!).nextSibling;\n    const oldParent = part._$parent;\n    const parentChanged = oldParent !== containerPart;\n    if (parentChanged) {\n      part._$reparentDisconnectables?.(containerPart);\n      // Note that although `_$reparentDisconnectables` updates the part's\n      // `_$parent` reference after unlinking from its current parent, that\n      // method only exists if Disconnectables are present, so we need to\n      // unconditionally set it here\n      part._$parent = containerPart;\n      // Since the _$isConnected getter is somewhat costly, only\n      // read it once we know the subtree has directives that need\n      // to be notified\n      let newConnectionState;\n      if (\n        part._$notifyConnectionChanged !== undefined &&\n        (newConnectionState = containerPart._$isConnected) !==\n          oldParent!._$isConnected\n      ) {\n        part._$notifyConnectionChanged(newConnectionState);\n      }\n    }\n    if (endNode !== refNode || parentChanged) {\n      let start: Node | null = part._$startNode;\n      while (start !== endNode) {\n        const n: Node | null = wrap(start!).nextSibling;\n        wrap(container).insertBefore(start!, refNode);\n        start = n;\n      }\n    }\n  }\n\n  return part;\n};\n\n/**\n * Sets the value of a Part.\n *\n * Note that this should only be used to set/update the value of user-created\n * parts (i.e. those created using `insertPart`); it should not be used\n * by directives to set the value of the directive's container part. Directives\n * should return a value from `update`/`render` to update their part state.\n *\n * For directives that require setting their part value asynchronously, they\n * should extend `AsyncDirective` and call `this.setValue()`.\n *\n * @param part Part to set\n * @param value Value to set\n * @param index For `AttributePart`s, the index to set\n * @param directiveParent Used internally; should not be set by user\n */\nexport const setChildPartValue = <T extends ChildPart>(\n  part: T,\n  value: unknown,\n  directiveParent: DirectiveParent = part\n): T => {\n  part._$setValue(value, directiveParent);\n  return part;\n};\n\n// A sentinal value that can never appear as a part value except when set by\n// live(). Used to force a dirty-check to fail and cause a re-render.\nconst RESET_VALUE = {};\n\n/**\n * Sets the committed value of a ChildPart directly without triggering the\n * commit stage of the part.\n *\n * This is useful in cases where a directive needs to update the part such\n * that the next update detects a value change or not. When value is omitted,\n * the next update will be guaranteed to be detected as a change.\n *\n * @param part\n * @param value\n */\nexport const setCommittedValue = (part: Part, value: unknown = RESET_VALUE) =>\n  (part._$committedValue = value);\n\n/**\n * Returns the committed value of a ChildPart.\n *\n * The committed value is used for change detection and efficient updates of\n * the part. It can differ from the value set by the template or directive in\n * cases where the template value is transformed before being commited.\n *\n * - `TemplateResult`s are committed as a `TemplateInstance`\n * - Iterables are committed as `Array<ChildPart>`\n * - All other types are committed as the template value or value returned or\n *   set by a directive.\n *\n * @param part\n */\nexport const getCommittedValue = (part: ChildPart) => part._$committedValue;\n\n/**\n * Removes a ChildPart from the DOM, including any of its content.\n *\n * @param part The Part to remove\n */\nexport const removePart = (part: ChildPart) => {\n  part._$notifyConnectionChanged?.(false, true);\n  let start: ChildNode | null = part._$startNode;\n  const end: ChildNode | null = wrap(part._$endNode!).nextSibling;\n  while (start !== end) {\n    const n: ChildNode | null = wrap(start!).nextSibling;\n    (wrap(start!) as ChildNode).remove();\n    start = n;\n  }\n};\n\nexport const clearPart = (part: ChildPart) => {\n  part._$clear();\n};\n","export const fmt = {\n    err: (err?: Error) => {\n        return err?.message || err\n    }\n}","import {CustomElementDefinition, CustomEvents} from \"../ui-types.js\";\nimport {css} from \"./css.js\";\nimport {component} from \"haunted\"\nimport type {component as componentCreator} from \"haunted\"\nimport { Options } from \"haunted/lib/core.js\";\n\ntype defineComponentOpts<P extends object = {}, E extends CustomEvents = {}> = {\n    func: CustomElementDefinition<P, E>,\n    hauntedOptions?: {\n        baseElement?: any;\n        observedAttributes?: (keyof P)[];\n        useShadowDOM?: boolean;\n        shadowRootInit?: ShadowRootInit;\n    }\n};\n\nexport function defineComponent<P extends object = {}, E extends CustomEvents = {}>(tagName: string, opts: defineComponentOpts<P, E>) {\n    css`${tagName} {display: block}`\n    customElements.define(tagName, component(opts.func as any, opts.hauntedOptions ?? {useShadowDOM: false}));\n    return opts.func;\n}","let memory: string[] = [];\n\nexport const css = (template: TemplateStringsArray | string, ...values: (string | number)[]) => {\n\n    let text = \"\";\n\n    if (Array.isArray(template)) {\n        for (let i = 0; i < template.length; i++) {\n            text += template[i];\n            text += i === template.length - 1 ? \"\" : values[i];\n        }\n    } else {\n        text = template as string\n    }\n\n    if (memory.indexOf(text) > -1) return\n\n    let styleElement = document.createElement(\"style\");\n    styleElement.innerHTML = text;\n    document.head.appendChild(styleElement);\n\n    memory.push(text);\n};","import StripeTypes from \"@stripe/stripe-js\";\nimport {component} from \"haunted\";\nimport {useEffect, useRef} from \"haunted/lib/core.js\";\nimport {CreateCustomEvent, CustomElement, CustomElementDefinition} from \"../../../ui-types.js\";\nimport {Nullable} from \"../../../../_/types.js\";\nimport {useAwait} from \"../../../util/hooks/use-await.js\";\nimport {StripeContextType} from \"./types.js\";\nimport {StripeContext} from \"./stripe-context.js\";\nimport {css} from \"../../../util/css.js\";\nimport \"./stripe-context.js\"\nimport {NarrowedStripeCalculatedCheckout} from \"../../../../payment/payment-stripe-types.js\";\nimport {NonUndefined} from \"utility-types\";\n\nexport type StripeCardformEvents = {\n    elementready: { elementType: string },\n\n    /**\n     * Need to send the transaction token\n     * to your api in order to capture the payment\n     */\n    \"payment-method-token\": NonUndefined<NarrowedStripeCalculatedCheckout[\"clientData\"]>\n};\n\nexport type StripeFormProps = {\n    stripeClient?: StripeTypes.Stripe,\n    stripePublicKey?: string,\n    stripeClientSecret?: string,\n    value: StripeContextType\n};\n\nexport type StripeFormDefinition = CustomElementDefinition<StripeFormProps, StripeCardformEvents>;\n\ncss`stripe-form { display: block }`\n\n//TODO: Rename it to StripeContextElelement\nexport const StripeForm: StripeFormDefinition = function ({stripeClient, stripeClientSecret, stripePublicKey}) {\n    const stripeRef = useRef(null as Nullable<StripeContextType>);\n\n    const useSubmit = useAwait(async () => {\n            if (stripeRef.current) {\n                const {stripeElements} = stripeRef.current;\n                const stripeCardElement = stripeElements.getElement(\"cardNumber\") || stripeElements.getElement(\"card\");\n\n                if (!stripeCardElement) {\n                    throw \"Input not found\"\n                }\n                this.dispatchEvent(CreateCustomEvent(\"payment-method-token\", {\n                    detail: {\n                        cardElement: stripeCardElement\n                    }, bubbles: true\n                }))\n            }\n        }\n        ,(data) => {\n            if (this.value) {\n                this.value = {...this.value, useSubmit: {...data}};\n            }\n        });\n\n    const stripeCb = useAwait(async () => {\n        const loadStripeClient = async () => {\n            if (stripePublicKey) {\n                const stripeLib = await import('@stripe/stripe-js');\n                return stripeLib.loadStripe(stripePublicKey)\n            }\n        }\n\n        const stripe = stripeClient ?? await loadStripeClient();\n        if (!stripe) throw \"Could not load stripe\";\n\n        const stripeElements = stripe.elements({clientSecret: stripeClientSecret});\n\n        stripeRef.current = {\n            stripeClient: stripe,\n            stripeElements: stripeElements,\n            useSubmit: useSubmit\n        };\n\n        this.value = stripeRef.current;\n    });\n\n    useEffect(() => {\n        if (!stripeRef.current) {\n            stripeCb.run();\n        }\n    }, []);\n}\n\ncustomElements.define(\"stripe-form\", component(StripeForm, {\n    useShadowDOM: false,\n    baseElement: StripeContext.Provider,\n    observedAttributes: [\"stripe-public-key\"] as any\n}))","import {useState} from \"haunted/lib/core.js\";\nimport {inlineErr} from \"../../../inline-error.js\";\nimport {Undefinable} from \"../../../_/types.js\";\n\ntype useAwaitReturnType<T extends ((...args: any[]) => Promise<R>), R> = { run: T, result: Undefinable<R>, loading: boolean, err: undefined | Error };\ntype useAwaitType<T extends ((...args: any[]) => Promise<R>), R> = useAwaitReturnType<T, R>;\n\n/**\n *\n * @param job Async function to be executed\n * @param cb Callback executed everytime the stats change\n */\nexport function useAwait<R, T extends ((...args: any[]) => Promise<R>)>(job: T, cb?: (stats: useAwaitReturnType<T, R>) => void): useAwaitType<T, R> {\n    const [loading, setLoading] = useState(false);\n    const [err, setErr] = useState(undefined as undefined | Error);\n    const [result, setResult] = useState(undefined as Undefinable<R>);\n\n    const run = (async (...args) => {\n        if (!loading) {\n            setLoading(true);\n            setErr(undefined as any);\n            const [result, err] = await inlineErr(job(...args));\n            setErr(err as any);\n            setResult(result as any);\n            setLoading(false);\n            return result;\n        }\n    }) as T;\n\n    const awaitStats: useAwaitReturnType<T, R> = {\n        run,\n        loading,\n        result: result as Undefinable<R>,\n        err\n    };\n\n    if (cb) {\n        cb(awaitStats);\n    }\n\n    return awaitStats;\n}"],"names":["parcelRequire","$6LkPz","$9raST","defineComponent","func","props","stripeContext","$apSal","useContext","$1WPke","StripeContext","stripeElm","setStripeElm","$baDDu","useState","$kHQsm","useEffect","stripeElements","create","type","opts","container","document","createElement","mount","on","e","this","dispatchEvent","CreateCustomEvent","detail","bubbles","err","useSubmit","$fUwgm","html","$kMbkQ","fmt","submitCb","run","addEventListener","removeEventListener","$3f851a735d5a6d5d$export$a4eb9e8384d3a313","eventInit","window","CustomEvent","$V6cQb","$99d4f7e673ebf316$export$2e2bcd8739ae039","render","component","makeComponent","$5qXKv","makeContext","$7BPNg","$0aba2363ca8d9e59$export$3bc26eec1cc2439f","Scheduler","BaseScheduler","frag","constructor","renderer","host","super","commit","result","baseElementOrOptions","options","BaseElement","baseElement","HTMLElement","observedAttributes","useShadowDOM","shadowRootInit","Element","_scheduler","attachShadow","mode","shadowRoot","connectedCallback","update","disconnectedCallback","teardown","attributeChangedCallback","name","oldValue","newValue","val","Reflect","set","replace","_","char","toUpperCase","$0aba2363ca8d9e59$var$toCamelCase","proto","Proxy","prototype","getPrototypeOf","target","key","value","receiver","desc","Object","getOwnPropertyDescriptor","call","enumerable","configurable","writable","initialValue","isSetup","freeze","get","reflectiveProp","defineProperty","setPrototypeOf","$5sUJq","$58a42a3fda191fbb$var$defer","Promise","resolve","then","bind","$58a42a3fda191fbb$var$runner","id","tasks","runTasks","t","i","len","length","task","push","$58a42a3fda191fbb$var$read","$58a42a3fda191fbb$var$write","$58a42a3fda191fbb$export$61cd7faa6f3316a3","state","$aznSH","phaseSymbol","_updateQueued","State","handlePhase","updateSymbol","commitSymbol","effectsSymbol","phase","arg","runEffects","layoutEffectsSymbol","_runEffects","$4qTmM","$3fab92ffbfd3a6ca$export$7254cc27399e90bd","virtual","hookSymbol","Map","cb","setCurrent","res","clear","effects","effect","runLayoutEffects","forEach","hook","$33a489bf88ca5600$export$97aac956da55dae9","$33a489bf88ca5600$var$currentId","$33a489bf88ca5600$export$5f80f094fd31fffd","$33a489bf88ca5600$export$42ffd38884aecdac","$33a489bf88ca5600$export$5e14cdade93d6f7b","$7b1fb29716cbd4a0$export$225ab0e0febd92b1","Symbol","$7b1fb29716cbd4a0$export$819a7f3d5f1d869d","$7b1fb29716cbd4a0$export$e3a0ce117547085d","$7b1fb29716cbd4a0$export$c3840c26fe093fdb","$7b1fb29716cbd4a0$export$8e8d58c9b17fea3e","$7b1fb29716cbd4a0$export$db08efd2f456c5bf","$7b1fb29716cbd4a0$export$c1645e5fb9a50701","$3f4dba5ed30283fd$export$2d2e2a019c76af3","defaultValue","Context","Provider","listeners","_value","Set","contextEvent","handleEvent","event","unsubscribe","callback","add","stopPropagation","delete","Consumer","$99SrJ","$79564161704eb40b$export$fae74005e78b1a27","Hook","_ranEffect","_unsubscribe","_updater","setEffects","Error","_subscribe","cancelable","composed","$6aaf30390afc2d23$export$e594a57fbda5c090","$6aaf30390afc2d23$var$use","args","notify","hooks","current","$6aaf30390afc2d23$export$1062a250c78723ea","$f130839135fbaa9e$export$2ff5f1970029d8ea","$f130839135fbaa9e$export$6d9c69b0de29b591","createEffect","$1d3c29b774fa6244$export$7ea7134f704deda4","lastValues","values","_teardown","ignored1","ignored2","hasChanged","some","$abff72d3d22f80c0$export$1538c33de8887b59","fn","$8568ea84b72dd5bc$export$e5c5a5f917a5871c","$821f5fc147375fd9$export$60241385465d0a34","updater","makeArgs","updaterFn","previousValue","reducer","currentState","initialState","init","dispatch","undefined","action","$eLxvF","$c9fe9408bcde7c72$export$b8f5890fc79d6aca","useMemo","$5899b42b69c36e45$export$bdc250ccffdc5290","createContext","customElements","define","$05169e617da7d7b1$export$d8556a2a8f973135","$05169e617da7d7b1$export$fd42f52fd3ae1109","$dcQiV","default","$iXFJB","makeVirtual","$gyXG7","$dcde1c482aeb4fc5$var$includes","Array","includes","$dcde1c482aeb4fc5$var$partToScheduler","WeakMap","$dcde1c482aeb4fc5$var$schedulerToPart","$dcde1c482aeb4fc5$var$Scheduler","setValue","part","apply","$dcde1c482aeb4fc5$export$3b9595dc33c67676","VirtualDirective","$swPBy","AsyncDirective","cont","partInfo","r","$dcde1c482aeb4fc5$var$teardownOnRemove","noChange","directive","node","startNode","parentNode","mo","MutationObserver","mutations","mutation","removedNodes","disconnect","ShadowRoot","addedNodes","nextSibling","observe","childList","PartType","ATTRIBUTE","CHILD","PROPERTY","BOOLEAN_ATTRIBUTE","EVENT","ELEMENT","c","_$litDirective$","Directive","_partInfo","_$isConnected","_$parent","_$initialize","parent","attributeIndex","__part","__attributeIndex","_$resolve","_part","notifyChildrenConnectedChanged","isConnected","children","_$disconnectableChildren","obj","_b","_a","_$AO","o","s","removeDisconnectableFromParent","size","addDisconnectableToParent","has","installDisconnectAPI","reparentDisconnectables","newParent","notifyChildPartConnectedChanged","isClearingValue","fromPartIndex","_$committedValue","isArray","_c","_$notifyConnectionChanged","_d","_$reparentDisconnectables","isClearingDirective","n","reconnected","disconnected","isSingleExpression","_$setValue","newValues","_ChildPart","ChildPart","_$LH","strings","$4215dc36c9033de2$export$bc71a178fd8db0f","message","$015Dq","$f2581f76935f6c5e$export$afa64b67e5a01c3b","tagName","css","$r5hta","hauntedOptions","$09f4cbe07b977ff0$var$memory","$09f4cbe07b977ff0$export$dbf350e5966cf602","template","text","indexOf","styleElement","innerHTML","head","appendChild","stripeClient","stripeClientSecret","stripePublicKey","stripeRef","$hld7L","useRef","$3ncAX","useAwait","async","stripeCardElement","getElement","cardElement","data","stripeCb","stripe","loadStripe","loadStripeClient","elements","clientSecret","$791d2e5aceadb982$export$6de935e3b3681947","job","loading","setLoading","setErr","setResult","awaitStats","$kfWYW","inlineErr"],"version":3,"file":"dependencies.f00f15b7.js.map"}